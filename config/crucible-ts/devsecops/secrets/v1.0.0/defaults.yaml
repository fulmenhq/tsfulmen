# DevSecOps Project Secrets - Default Configuration
#
# This file provides sample configurations for project-scoped secrets files
# conforming to schemas/devsecops/secrets/v1.0.0/secrets.schema.json
#
# Used by: fulmen-secrets (fulsecrets) CLI tool, L'Orage Central, Etknow microtool
#
# WARNING: This is a SAMPLE file with anonymized/fake secrets for demonstration.
#          DO NOT commit real secrets to version control in plaintext.
#          Use encryption (fulsecrets encrypt) before committing production secrets.
#
# SCHEMA LIMITS (v1.0.0 hardening - v0.2.19):
#   - Credential values: max 65,536 chars (64KB, UTF-8)
#   - Credential refs: max 2,048 chars (printable ASCII only)
#   - Descriptions (file/project/credential): max 4,096 chars
#   - Credential key names: max 255 chars (OS env var limit)
#   - Projects per file: max 256
#   - Credentials per project: max 1,024
#
# These limits provide DoS protection while supporting legitimate use cases.
# Example 1: Minimal Development Environment (Plaintext)
# Use case: Local development with non-sensitive test credentials
# Policy: allow_plain_secrets = true (default)
schema_version: v1.0.0
env_prefix: APP_
projects:
  - project_slug: myapp-dev
    credentials:
      DATABASE_URL:
        type: password
        value: postgres://localhost:5432/myapp_dev
      REDIS_URL:
        type: password
        value: redis://localhost:6379/0
      API_KEY:
        type: api_key
        value: dev_key_12345_not_real
      SECRET_TOKEN:
        type: token
        value: dev_secret_abc_not_real
      LOG_LEVEL:
        type: password
        value: debug
policies:
  allow_plain_secrets: true # OK for development

# Example 2: Full-Featured Credentials with Metadata & Rotation
# Use case: Production secrets with lifecycle tracking and rotation policies
# Pattern: Rich credential objects with type, metadata, rotation
---
schema_version: v1.0.0
description: |
  Production secrets for MyApp platform
  Contact: platform-team@example.com
  Last updated: 2025-11-17
env_prefix: PROD_
projects:
  - project_slug: backend_api
    description: Backend API services
    credentials:
      STRIPE_API_KEY:
        type: api_key
        value: sk_live_abc123def456_not_real
        description: Live Stripe API key for payment processing
        metadata:
          created: "2025-01-15T10:00:00Z"
          expires: "2026-01-15T10:00:00Z"
          last_rotated: "2025-10-15T10:00:00Z"
          next_rotation: "2026-01-15T10:00:00Z"
          rotation_count: 3
          purpose: payment-processing
          tags:
            - payment
            - critical
            - pci-scope
          owner: payments-team
          service_name: Stripe
          service_url: https://api.stripe.com
          required_scope: "charges:write,customers:read"
          compliance_tags:
            - pci-dss
            - soc2
          environment: production
          tier: critical
        rotation:
          interval: 90d
          method: auto
      DATABASE_PASSWORD:
        type: password
        value: super_secure_password_not_real
        description: Primary PostgreSQL database password
        metadata:
          created: "2025-01-01T00:00:00Z"
          expires: "2025-12-31T23:59:59Z"
          purpose: primary-database
          tags:
            - database
            - critical
          owner: platform-team
        rotation:
          interval: 30d
          method: manual
      JWT_SECRET:
        type: token
        value: bearer_token_abc123_not_real
        description: JWT signing secret for authentication
        metadata:
          purpose: authentication
          tags:
            - auth
            - critical
      REDIS_PASSWORD:
        type: password
        value: redis_password_xyz789_not_real
        description: Redis cache password

# Example 3: Multi-Project with External References
# Use case: Monorepo with multiple services, some credentials from Vault
# Pattern: Mix of inline values and external references (vault://, aws-secrets://)
---
schema_version: v1.0.0
projects:
  - project_slug: api-staging
    credentials:
      DATABASE_URL:
        type: password
        ref: vault://secrets/staging/db-url
        description: Database URL from HashiCorp Vault
      REDIS_URL:
        type: password
        value: redis://staging-cache.internal:6379
      JWT_SECRET:
        type: token
        value: staging_jwt_secret_abc123_not_real
      API_KEY:
        type: api_key
        value: sk_staging_api_key_not_real
      SENTRY_DSN:
        type: password
        value: https://fake@sentry.io/staging
  - project_slug: worker-staging
    credentials:
      DATABASE_URL:
        type: password
        ref: vault://secrets/staging/db-url # Shared reference
      QUEUE_URL:
        type: password
        value: amqp://staging-queue.internal:5672
      WORKER_TOKEN:
        type: token
        value: staging_worker_token_xyz789_not_real
      SENTRY_DSN:
        type: password
        value: https://fake@sentry.io/staging
  - project_slug: frontend_staging
    env_prefix: VITE_ # Override global prefix for frontend
    credentials:
      API_URL:
        type: password
        value: https://api-staging.example.com
      ANALYTICS_KEY:
        type: api_key
        value: staging_analytics_key_not_real
      SENTRY_DSN:
        type: password
        value: https://fake@sentry.io/staging

# Example 4: Production Environment (Encrypted - GPG)
# Use case: Production secrets encrypted with GPG for team access
# Policy: allow_plain_secrets = false (enforce encryption)
#
# How to create:
#   1. Create plaintext file with real secrets (using credential objects)
#   2. Run: fulsecrets encrypt secrets.yaml --gpg-key team@example.com
#   3. Commit encrypted file to version control
#
# How to use:
#   fulsecrets exec -p myapp-prod -- npm start
#   (prompts for GPG passphrase, decrypts in memory, runs command)
---
schema_version: v1.0.0
encryption:
  method: gpg
  key_id: 7A8B9C0D1E2F3A4B # GPG key fingerprint
  encrypted_at: "2025-11-15T10:00:00Z"
  cipher: AES-256-GCM
# The 'projects' array is encrypted inside this ciphertext blob
# When decrypted, it contains:
#   projects:
#     - project_slug: myapp-prod
#       credentials:
#         DATABASE_URL:
#           type: password
#           value: postgres://prod-db.example.com:5432/myapp
#         API_KEY:
#           type: api_key
#           value: sk_live_real_production_key
#           metadata:
#             expires: "2026-01-01T00:00:00Z"
#           rotation:
#             interval: 90d
#             method: auto
ciphertext: |
  -----BEGIN PGP MESSAGE-----

  hQIMA3xQvBF2g8NSAQ//ZQWJRW8F... [This is a fake/truncated example]
  ...real encrypted payload would be here...
  -----END PGP MESSAGE-----
policies:
  allow_plain_secrets: false # Enforce encryption for production

# Example 5: Production Environment (Encrypted - age)
# Use case: Modern encryption with age instead of GPG
# Pattern: Same as GPG but using age public/private key pairs
#
# How to create:
#   1. Generate age keypair: age-keygen -o ~/.config/fulsecrets/key.txt
#   2. Store public key in team docs, private key secure
#   3. Run: fulsecrets encrypt secrets.yaml --age-recipient age1ql3z...
#
# How to use:
#   fulsecrets exec -p myapp-prod --age-identity ~/.config/fulsecrets/key.txt -- npm start
---
schema_version: v1.0.0
encryption:
  method: age
  key_id: age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p
  encrypted_at: "2025-11-15T14:30:00-05:00"
  cipher: ChaCha20-Poly1305
ciphertext: |
  YWdlLWVuY3J5cHRpb24ub3JnL3YxCi0+IFgyNTUxOSBE...
  [This is a fake/truncated base64 example]
  ...real encrypted payload would be here...
policies:
  allow_plain_secrets: false

# Example 6: Passphrase-Based Encryption (Simplest)
# Use case: Solo developer or small team with shared passphrase
# Pattern: No key management needed, just a strong passphrase
#
# How to create:
#   fulsecrets encrypt secrets.yaml --passphrase
#   (prompts for passphrase, encrypts symmetrically)
#
# How to use:
#   fulsecrets exec -p myapp-prod --passphrase -- npm start
#   (prompts for passphrase to decrypt)
#
# CI/CD usage:
#   export FULSECRETS_PASSPHRASE="${{ secrets.FULSECRETS_PASSPHRASE }}"
#   fulsecrets exec -p myapp-prod --passphrase -- ./deploy.sh
#   (reads passphrase from env var, no prompt)
---
schema_version: v1.0.0
encryption:
  method: passphrase
  encrypted_at: "2025-11-15T16:00:00Z"
  cipher: AES-256-GCM
  # No key_id for passphrase-based encryption
ciphertext: |
  U2FsdGVkX1+abcd1234... [This is a fake/truncated example]
  ...real encrypted payload would be here...
policies:
  allow_plain_secrets: false

# Best Practices & Security Notes:
#
# 1. Credential Types:
#    - api_key: External service keys (Stripe, GitHub, AWS) - masked as "sk_live_...xyz"
#    - token: Auth tokens, JWTs, bearer tokens - masked as "...1234"
#    - password: Passwords, passphrases, DB URLs - fully redacted "***REDACTED***"
#
# 2. Value vs Ref:
#    - Use 'value' for inline secrets (development, small deployments)
#    - Use 'ref' for external secret managers (Vault, AWS Secrets Manager)
#    - Never include both 'value' and 'ref' (mutually exclusive)
#
# 3. Metadata & Rotation:
#    - Add 'metadata.expires' for time-based rotation tracking
#    - Use 'rotation.interval' to document rotation policy (30d, 90d, 180d)
#    - Set 'rotation.method: auto' for automated rotation, 'manual' otherwise
#    - Tag critical credentials with 'tags: [critical]' for monitoring
#
# 4. NEVER commit plaintext production secrets to version control:
#    - Always encrypt production files before git add
#    - Use .gitignore for *-plain.yaml, *-decrypted.yaml patterns
#    - Run 'git secrets --scan' or similar tools to prevent leaks
#
# 5. Policy enforcement:
#    - Set allow_plain_secrets: false for staging/production
#    - Keep allow_plain_secrets: true for local development
#    - Use fulsecrets validate --strict to catch violations
#
# 6. Key management:
#    - GPG: Good for teams with existing GPG infrastructure
#    - Age: Modern alternative, simpler key management
#    - Passphrase: Simplest for solo dev, store in password manager
#
# 7. CI/CD integration:
#    - Store passphrases/keys in GitHub Secrets / GitLab CI Variables
#    - Use environment variables (FULSECRETS_PASSPHRASE) to avoid prompts
#    - Never echo/print secrets in CI logs
#
# 8. Secret rotation workflow:
#    - Decrypt existing file: fulsecrets decrypt secrets.yaml
#    - Update credential values and metadata.expires timestamps
#    - Re-encrypt with same method: fulsecrets encrypt secrets.yaml
#    - For key rotation: decrypt, re-encrypt with new key
#
# 9. Temporary files:
#    - fulsecrets edit uses secure temp files (/dev/shm, 0600 perms)
#    - Manual workflow: always rm plaintext files after encryption
#    - Use shred/srm for sensitive cleanup if available
#
# 10. Environment variable naming:
#     - Use UPPER_SNAKE_CASE for credential keys
#     - Add env_prefix for namespacing (APP_, SERVICE_, PROD_, etc.)
#     - Avoid generic names like "KEY" or "TOKEN" (use API_KEY, JWT_TOKEN)
#     - Global env_prefix applies to all projects, can override per-project
#
# 11. Project slugs:
#     - Use lowercase alphanumeric + hyphens/underscores
#     - Pattern: service-environment (api-staging, worker-prod)
#     - Or: service_version-env (api_v2-staging, backend_legacy-prod)
#     - Examples: backend-api, frontend_app, worker-staging, my_service-v2
#
# 12. Compliance / FIPS mode:
#     - Set allow_plain_secrets: false for compliance
#     - Use GPG with FIPS 140-2 validated crypto if required
#     - Document encryption method in security policy
#     - Track rotation with metadata.expires and rotation.interval
#
# Schema Documentation:
#   https://github.com/fulmenhq/crucible/blob/main/docs/standards/devsecops/project-secrets.md
#
# CLI Tool (fulmen-secrets / fulsecrets):
#   https://github.com/fulmenhq/fulmen-secrets
---
