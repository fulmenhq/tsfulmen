---
id: "ADR-0014"
title: "OpenAPI Spec Coverage Tests"
status: "accepted"
date: "2026-01-12"
last_updated: "2026-01-12"
deciders:
  - "@3leapsdave"
scope: "Ecosystem"
tags:
  - "openapi"
  - "testing"
  - "fixtures"
  - "servers"
  - "documentation"
related_adrs: []
adoption:
  gofulmen: "not-applicable"
  pyfulmen: "not-applicable"
  tsfulmen: "not-applicable"
  rsfulmen: "not-applicable"
  csfulmen: "not-applicable"
---

# ADR-0014: OpenAPI Spec Coverage Tests

## Status

**Current Status**: Accepted

## Context

Fulmen fixtures and workhorses increasingly publish OpenAPI specifications as build artifacts (e.g., generated by `swaggo/swag` into `dist/openapi.yaml`) and serve them at runtime (e.g., `GET /openapi.yaml`).

A recurring failure mode is **spec drift**:

- New endpoints are added to the server/router, but OpenAPI annotations are not added
- The generator produces a partial spec (often only annotated endpoints)
- Reviewers/consumers assume the spec represents the full API surface

This creates misleading documentation and breaks client generation/validation workflows. Both `fixture-server-proving-gauntlet` and `fixture-server-proving-rampart` independently encountered this issue and adopted identical mitigations, indicating the pattern warrants ecosystem standardization.

### Problem Scope

| Affected Category | Frequency                | Impact                                           |
| ----------------- | ------------------------ | ------------------------------------------------ |
| Fixtures          | High (all HTTP fixtures) | Consumers can't trust spec for client generation |
| Workhorses        | Medium (server-backends) | API documentation diverges from implementation   |
| DX Tools          | Low (most are CLI-only)  | Minimal (few expose HTTP APIs)                   |

## Decision

When an HTTP server publishes an OpenAPI specification as a build artifact, the repository MUST include an automated coverage test that asserts the spec covers all registered HTTP routes.

### Requirements by Repository Category

| Category                           | OpenAPI Publication | Coverage Test          | CI Enforcement |
| ---------------------------------- | ------------------- | ---------------------- | -------------- |
| Fixtures (proving, utility, chaos) | MUST                | MUST                   | MUST           |
| Workhorses                         | SHOULD              | SHOULD (if publishing) | SHOULD         |
| DX Tools (with HTTP API)           | MAY                 | MAY (if publishing)    | MAY            |
| Codex/Static Sites                 | N/A                 | N/A                    | N/A            |

### Coverage Test Behavior

The test MUST:

1. Parse registered routes from the router source-of-truth (e.g., `mux.HandleFunc` registrations in Go)
2. Parse `paths` + HTTP methods from the generated OpenAPI spec
3. Fail if any registered route/method pair is missing from the spec (unless explicitly excluded)

The test SHOULD:

- Skip gracefully when the spec artifact is absent (developer convenience for local iteration)
- Report which specific routes are missing (actionable error messages)
- Normalize path parameters (`{param}` treated equivalently across router and spec)

### Intentional Exclusions

Maintainers MAY intentionally exclude endpoints from OpenAPI documentation. Valid reasons include:

| Exclusion Reason         | Example                   | Recommendation                  |
| ------------------------ | ------------------------- | ------------------------------- |
| Experimental endpoints   | `/experimental/v2/widget` | Exclude until stable            |
| Internal/admin endpoints | `/admin/debug/pprof`      | Exclude from public spec        |
| Deprecated endpoints     | `/v1/legacy-auth`         | Include with `deprecated: true` |
| Spec-serving endpoints   | `/openapi.yaml`           | Exclude (self-referential)      |

**Implementation**: Use an explicit exclusion list in the coverage test:

```go
var excludedRoutes = []string{
    "GET /openapi.yaml",      // Self-referential
    "GET /debug/pprof",       // Internal diagnostics
    "POST /experimental/v2/", // Not yet stable
}
```

**Best Practice**: All endpoints intended for long-term consumer use ("going concern" endpoints) SHOULD be documented. Exclusions should be the exception, not the rule. When in doubt, document the endpoint—consumers benefit from complete specifications.

### CI Workflow Integration

CI pipelines MUST run OpenAPI generation before tests:

```yaml
# Example GitHub Actions
- name: Generate OpenAPI
  run: make openapi

- name: Run Tests
  run: make test # Coverage test now has spec artifact
```

The test runner can be `make test`, `go test ./...`, `pytest`, or any language-appropriate command—the key requirement is that the spec artifact exists before the coverage test executes.

### Build Artifact Location

| Artifact                 | Recommended Path                 | Notes                            |
| ------------------------ | -------------------------------- | -------------------------------- |
| Generated spec           | `dist/openapi.yaml`              | Build artifact, gitignored       |
| Embedded spec (optional) | `internal/handlers/openapi.yaml` | If embedding for runtime serving |

**Swagger 2 vs OpenAPI 3**: The coverage test applies to both Swagger 2 (`swagger: "2.0"`) and OpenAPI 3 (`openapi: "3.x.x"`) specifications. Tools like `swag` emit Swagger 2 by default; this is acceptable. The coverage test validates route presence regardless of spec version.

### Release Asset Consideration

Repository maintainers SHOULD decide whether the OpenAPI spec should be included in release assets (`dist/release/`). If included:

- Add `openapi.yaml` to `dist/release/` during release preparation
- Document in release notes that the spec is available as a downloadable artifact
- Consider signing the spec alongside other release artifacts

This decision is repository-specific; some consumers prefer fetching specs from running servers, others from release downloads.

### Provenance and Metadata

OpenAPI specifications SHOULD include provenance metadata using the standard `info.x-*` extension mechanism (compatible with all OpenAPI tooling):

```yaml
openapi: "3.1.0"
info:
  title: "Rampart HTTP Testing Fixture"
  version: "1.0.0"
  x-generated-by: "swaggo/swag"
  x-generated-at: "2026-01-12T10:00:00Z"
  x-source-repo: "github.com/fulmenhq/fixture-server-proving-rampart"
  x-crucible-version: "0.4.6"
```

Do NOT add YAML frontmatter or comments before the `openapi:` key—this breaks spec parsers. All metadata MUST use OpenAPI's native extension points.

## Rationale

### Why Automated Testing

Manual review is unreliable:

- Reviewers may not check spec completeness
- Route additions often span multiple PRs
- Partial specs can ship unnoticed for months

Automated coverage tests provide:

- Immediate feedback on missing annotations
- CI enforcement preventing spec drift
- Self-documenting test failures

### Why This Belongs in Crucible

- **Cross-repo**: Pattern applies equally to gauntlet, rampart, and future fixtures
- **Cross-language**: Concept is language-agnostic (only extraction mechanism differs)
- **Reviewer-facing**: Standard that materially improves ecosystem quality
- **Prevents duplication**: Both fixture repos independently created identical ADR-0001

## Alternatives Considered

### Alternative 1: Rely on Code Review

**Description**: Trust reviewers to verify spec completeness manually.

**Pros**:

- No additional test infrastructure
- Human judgment for edge cases

**Cons**:

- Unreliable—easy to miss
- No CI enforcement
- Already failed in practice (gauntlet/rampart both had drift)

**Decision**: Rejected - Insufficient for ecosystem quality goals

### Alternative 2: Generate Spec from Router (No Annotations)

**Description**: Auto-generate OpenAPI from router registrations without annotations.

**Pros**:

- Guaranteed coverage
- No annotation maintenance

**Cons**:

- Loses rich documentation (descriptions, examples, schemas)
- Many languages lack mature tooling for this approach
- Doesn't support response schemas or complex request bodies

**Decision**: Rejected - Sacrifices documentation quality for coverage

### Alternative 3: Runtime Spec Generation Only

**Description**: Generate spec at server startup, serve dynamically.

**Pros**:

- Always in sync with running code
- No build step

**Cons**:

- Startup latency
- Binary includes generator dependencies
- Can't validate spec without running server

**Decision**: Rejected - Build-time generation preferred for performance and validation

## Consequences

### Positive

- ✅ Prevents spec drift—consumers can trust published specs
- ✅ Forces documentation discipline—adding endpoints requires annotations
- ✅ Enables reliable client generation and SDK tooling
- ✅ Creates consistent fixture-level contract for testing infrastructure
- ✅ Catches missing documentation before merge

### Negative

- ⚠️ Requires CI to run `make openapi` before tests
- ⚠️ Adds small parsing logic to test suites (YAML + router patterns)
- ⚠️ Language-specific extraction logic needed per framework

### Neutral

- ℹ️ Test skips locally when artifact absent (acceptable for developer convenience)
- ℹ️ Does not validate response schemas or request bodies (separate concern)

## Implementation

### Implementation Pattern (Go with http.ServeMux)

```go
func TestOpenAPISpecCoverage(t *testing.T) {
    specPath := "dist/openapi.yaml"
    if _, err := os.Stat(specPath); os.IsNotExist(err) {
        t.Skip("OpenAPI spec not found; run 'make openapi' first")
    }

    // Parse spec
    specRoutes := parseOpenAPISpec(t, specPath)

    // Extract registered routes from server.go
    registeredRoutes := extractRouterRoutes(t, "internal/server/server.go")

    // Compare
    for _, route := range registeredRoutes {
        if !specRoutes.Contains(route.Method, route.Path) {
            t.Errorf("Route %s %s not documented in OpenAPI spec", route.Method, route.Path)
        }
    }
}
```

### Makefile Target

```makefile
openapi:  ## Generate OpenAPI specification
	@if ! command -v swag >/dev/null 2>&1; then \
		go install github.com/swaggo/swag/cmd/swag@latest; \
	fi
	@swag init -g cmd/$(BINARY_NAME)/main.go -o dist --outputTypes yaml
	@echo "OpenAPI spec generated: dist/openapi.yaml"

build: openapi  ## Build depends on openapi generation
	go build -o dist/$(BINARY_NAME) ./cmd/$(BINARY_NAME)
```

### Implementation Status

This ADR applies to application repositories (fixtures, workhorses), not helper libraries.

| Repository Type                 | Implementation | Notes                   |
| ------------------------------- | -------------- | ----------------------- |
| fixture-server-proving-rampart  | implemented    | ADR-0001 in repo        |
| fixture-server-proving-gauntlet | implemented    | ADR-0001 in repo        |
| Future fixtures                 | planned        | Will reference this ADR |
| Workhorse forges                | planned        | Template pattern        |

## Cross-Language Coordination

The coverage test concept is language-agnostic. Implementation varies by:

| Language   | Router Pattern                     | OpenAPI Generator          |
| ---------- | ---------------------------------- | -------------------------- |
| Go         | `http.ServeMux` patterns, chi, gin | swag, oapi-codegen         |
| Python     | FastAPI routes, Flask              | fastapi (native), flasgger |
| TypeScript | Express routes, Hono               | swagger-jsdoc, tsoa        |
| Rust       | Axum routes, Actix                 | utoipa, paperclip          |

Each language implementation should:

1. Parse router registrations from source files or runtime introspection
2. Parse OpenAPI YAML/JSON spec
3. Assert coverage with actionable error messages

## References

- [Fulmen Fixture Standard](../fulmen-fixture-standard.md) - Fixture repository requirements
- [Fulmen Forge Workhorse Standard](../fulmen-forge-workhorse-standard.md) - Workhorse template requirements
- [HTTP Server Patterns Guide](../../guides/testing/http-server-patterns.md) - Implementation patterns
- [HTTP REST Standard](../../standards/protocol/http-rest-standards.md) - HTTP API conventions
- [OpenAPI Specification](https://spec.openapis.org/oas/v3.1.0) - OpenAPI 3.1.0 specification
- [swaggo/swag](https://github.com/swaggo/swag) - Go OpenAPI generator

## Revision History

| Date       | Status Change | Summary                                                        | Updated By  |
| ---------- | ------------- | -------------------------------------------------------------- | ----------- |
| 2026-01-12 | → accepted    | Initial draft consolidating gauntlet/rampart ADR-0001 patterns | @3leapsdave |

---

**Schema Conformance**: This ADR conforms to [ADR Frontmatter Schema v1.0.0](https://schemas.fulmenhq.dev/standards/adr-frontmatter-v1.0.0.json)
